#!/usr/bin/ruby
require 'colorize'
#===============
@device = '/dev/mapper/root' 
@snapdir = '/.snapshots'
@snapvol = '@snapshots'
@rootvol = '@root'
@maxsnaps = 100
#===============
unless ENV['USER'] == 'root'
  puts "You should run as root. ABORTED."
  abort
end
#==========================
def now
 Time.new.strftime "%Y.%m.%d;%H:%M:%S"
end
#==========================
def letters
 return [*'a'..'z',*'A'..'Z']
end
#==========================
def snapid
  ids = `btrfs subvolume list / | grep #{@snapvol}/`
  id_list=[]
  ids.split("\n").each do |i|
    id_list<<i.split('/')[1].to_i
  end
  return id_list.sort
end
#==========================
def snapshot(comm,keep,fake)
  id = snapid.last.to_i + 1
  path = @snapdir + '/' + id.to_s
  ker = `uname -r`.chomp
  `mkdir #{path}`
  if comm.nil? then comm = '' end
  unless fake 
    puts `btrfs subvolume snapshot / #{path}/data` 
  end
  comm = comm.gsub(';','')
  info = "#{now};#{comm};#{ker};#{keep}"
  File.write("#{path}/info",info,mode:'w')
end
#==========================
def splitstr(string,shift)
  max = 35
  line = ''
  total = 0
  string.split(' ').each do |s|
    scut = s[0..max]
    total = total + scut.size
    if total < max
      line = line + scut + ' '
    else
      total = scut.size
      line = line + "\n" + ' '*shift + scut + ' ' 
    end
  end
  return line
end
#==========================
def readinfo(id)
  path = @snapdir + '/' + id.to_s
  unless Dir.exist? path then puts "There is no snapshot ID '#{id}'."; abort end
  info = File.read(path + '/info').strip.split(';')
  date  = info[0]
  time  = info[1]
  desc  = info[2]
  kernel= info[3]
  keep  = info[4]
  comm  = splitstr(desc,45)
  return [date,time,comm,kernel,keep]
end
#==========================
def list
    title = "TIMEPATROL SNAPSHOTS"
    legend= ' '*4+"ID"\
      +' '*2+"DATE"\
      +' '*8+"TIME"\
      +' '*6+"KERNEL"\
      +' '*9+"COMMENT"
    tlhalf = title.length/2
    nline = 72
    line = ("-".light_white)*nline
    lineline = ("=".light_white)*nline
    puts lineline
    puts " "*(nline/2-tlhalf)+title.yellow.bold
    puts lineline
    puts legend.bold
    snapid.each do |id|
      date   = readinfo(id)[0]
      time   = readinfo(id)[1]
      comm   = readinfo(id)[2]
      kernel = readinfo(id)[3]
      keep   = readinfo(id)[4]
      #--------------------
      space = 4-id.to_s.size
      kspace = 15 - kernel.size
      #--------------------
      kk=''
      if keep == '1' then kk='*'.green.bold;space-=1 end
      #--------------------
      id = '['+id.to_s.light_white+']'
      date = date.light_white
      time = time.light_white
      comm = comm.light_white
      kernel = kernel.light_white
      puts ' '*space\
        +kk+\
        +id+\
        +' '*2+date\
        +' '*2+time\
        +' '*2+kernel\
        +' '*kspace+comm
    end
    puts line
    puts "TOTAL: #{snapid.length}".bold
end
#============================
def rollback
  countdown = 10 # seconds before rebooting
  rollid = ARGV[1]
  if rollid.nil?
   puts "Choose a snapshot ID to rollback to or type any letter to ABORT:"
   rollid = STDIN.gets.strip
  end
  if letters.include? rollid
    puts 'ABORTED.'
    abort
  end
  #----------------------
  kernel_from = `uname -r`.chomp 
  kernel_to = readinfo(rollid)[3]
  if kernel_from != kernel_to
    puts "Running kernel (#{kernel_from}) is\
 different from snapshot '#{rollid}' kernel \
 (#{kernel_to}).\nABORTED.".red
    abort
  end
  #-----------------------
  puts "Rolling back to the following snapshot:".light_red
  puts showinfo(rollid).cyan
  puts "Confirm? [y/N]".light_red
  if STDIN.gets.chomp == 'y' 
    `mkdir #{@mnt} && mount -o subvolid=5 #{@device} #{@mnt}`
    #----------------
    check_root = Dir.exists? @mnt+'/'+@rootvol
    check_snap = Dir.exists? @mnt+'/'+@snapvol
    unless check_root and check_snap
      puts "Mounting stage went wrong. ABORTED.".red
      abort
    end
  #----------------
    id = snapid.last + 1
    date = readinfo(rollid)[0]
    time = readinfo(rollid)[1]
    snapshot("pre rollback to [#{date} #{time}]",-1,true)
    `mv #{@mnt}/#{@rootvol} #{@mnt}/#{@snapvol}/#{id}/data`
    `btrfs subvolume snapshot #{@mnt}/#{@snapvol}/#{rollid}/data #{@mnt}/#{@rootvol}`
    `umount #{@mnt} && rm -r #{@mnt}`
    root_id = `btrfs subvolume list / | grep #{@rootvol}`.split(' ')[1].to_i
    `btrfs subvolume set-default #{root_id} /`
    puts "Confirmed. Rebooting in..."
      (countdown-1).times do |i| 
        puts countdown-=1
        sleep 1
      end
      puts 'BUCKLE UP!'
      sleep 1
    `reboot`
    else
      puts "ABORTED."
    end
end
#==================================
def showinfo(id)
  date = readinfo(id)[0]
  time = readinfo(id)[1]
  comm = readinfo(id)[2]
  ker = readinfo(id)[3]
  nd = id.to_s.length
  space = " "*(3-nd)
  "#{space} [#{id}] #{date} #{time} #{ker} #{comm}" 
end
#==================================
def select(action)
#-------------------------------
  selid = ARGV[1]
  array_selected = []
  keyword = ['date=','time=','comment=','kernel=','keep=']
  if selid.nil?
    puts "Select snapshot(s) to #{action} or type any letter to ABORT:"
    selid = STDIN.gets.chomp
  end
  if letters.include? selid 
    puts "ABORTED."
    abort
  end
#---------------------------------
  keyword.each do |k|
    if selid.include? k then @special = true end
  end
#---------------------------------
  5.times do |j|
    if selid.include? keyword[j]
      snapid.each do |id|
        string = readinfo(id)[j]
        if string.include? selid.sub(keyword[j],'')
          array_selected<<id
        end
      end
    end
  end
#--------------------------------
  array_selid = selid.split(',')
  unless @special
    array_selid.each do |item|
      if item.include? '-' 
        selid_i = item.split('-').first.to_i
        selid_f = item.split('-').last.to_i
        if selid_i >= selid_f 
          puts "Bad range. ABORTED."
          abort 
        end
        snapid.each do |id|
          if id >= selid_i and id <= selid_f
            array_selected<<id
          end
        end
      else
        snapid.include? item
        array_selected<<item
      end
    end 
  end
#-----------------------------
  if array_selected.empty?
    puts "No snapshot meets the given criteria. ABORTED."
    abort
  end
  return array_selected
end
#==================================
def delete
  marked_for_deletion = select('delete'.red.bold)
    marked_for_deletion.each do |id|
      puts showinfo(id).cyan
    end
    puts "Confirm deletion of the selected snapshot(s) above? [y/N]".light_red
    ans = STDIN.gets.chomp
  if ans == 'y' 
    puts "Confirmed."
    marked_for_deletion.each do |id|
      code1 = `btrfs subvolume delete #{@snapdir}/#{id}/data; echo $?`.to_i
      code2 = `rm -r #{@snapdir}/#{id}; echo $?`.to_i 
      if code1+code2 > 0 then puts "FAILED deleting snapshot '#{id}'." end
    end
  else #if choosed N
    puts "ABORTED."
  end
end
#==========================
def repack
  puts "Renumbering snapshot IDs..."
  path = @snapdir+'/'
  snapid.each.with_index do |v,j|
    from = path+v.to_s
    to = path+(j+1).to_s
    if from != to
      `mv #{from} #{to}`
      puts "#{v} --> #{j+1}"
    end
  end
end
#==========================
def prune
  count = 0
  maxdel = snapid.length+1 - @maxsnaps
  snapid.each do |id|
    if count == maxdel then break end
    unless readinfo(id)[4]=='1'
      code1 = `btrfs subvolume delete #{@snapdir}/#{id}/data; echo $?`.to_i\
      code2 =  `rm -r #{@snapdir}/#{id}; echo $?`.to_i 
      if code1+code2 > 0 
        puts "FAILED deleting snapshot '#{id}'." 
      else
        puts "Deleted snapshot '#{id}'."
        count+=1
      end
    end
  end
end
#==========================
def mark
  marked_for_toggle = select('toggle KEEP'.green.bold)
    marked_for_toggle.each do |id|
      file    = @snapdir+'/'+id.to_s+'/info' 
      date    = readinfo(id)[0]
      time    = readinfo(id)[1]
      comm    = readinfo(id)[2]
      kernel  = readinfo(id)[3]
      keep    = (-readinfo(id)[4].to_i+2)/2
      info = date+';'+time+';'+comm+';'+kernel+';'+keep.to_s
      File.write(file,info,mode:'w')
    end
end
#==================================
#==================================
#==================================
opt = ARGV[0]
if opt.nil? then opt = 'help' end
@mnt = '/mnt/tptmp'
#==================================
if opt == 'toggle-keep'
  if ARGV[1].nil?
    list; mark
  else
    mark
  end
end
#-----------------------------------
if opt.include? 'snapshot'
  keep = 0
  if opt == 'snapshot-keep' then keep = 1 end 
  if snapid.last > 900 then repack end
  if snapid.length >= @maxsnaps then prune end
  snapshot(ARGV[1],keep,false,)
end
#-----------------------------------

if opt == 'list'
  list
end
#-----------------------------------
if opt == 'rollback'
  warning = "The '#{@mnt}' folder should not exist. ABORTED."
  if Dir.exists? @mnt then puts warning; abort end
  if ARGV[1].nil?
    list; rollback
  else
    rollback
  end
end
#-----------------------------------

if opt == 'delete'
  if ARGV[1].nil?
    list; delete
  else 
    delete
  end
end
#-----------------------------------
if opt == 'help' 
  puts 'USAGE:    timepatrol [COMMAND]'
  puts '------------------------------'
  puts 'COMMANDS:'
  puts "          snapshot 'COMMENT'"
  puts "          toggle-keep"
  puts '          delete'
  puts '          rollback'
  puts '          list'
end

